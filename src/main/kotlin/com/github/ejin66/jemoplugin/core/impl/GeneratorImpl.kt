package com.github.ejin66.jemoplugin.core.impl

import com.github.ejin66.jemoplugin.core.* // ktlint-disable no-wildcard-imports

class GeneratorImpl : IGenerator {

    private lateinit var lineFeed: String

    private var clsNumber = 0

    private val generatorCodeHeader = """
        /*
          Don't edit.
          Code generated by jemo.
        */

        import 'dart:convert';
    """.trimIndent()

    private val space = "    "
    private val createdClass = mutableListOf<String>()

    override fun generate(nodes: List<Node>, lineFeed: String): String {
        this.lineFeed = lineFeed

        var code = generatorCodeHeader + lineFeed

        for (node in nodes) {
            if (node is ImportNode) {
                code += generateImportNode(node)
                continue
            }

            code += lineFeed + generateNode(node).trim() + lineFeed
        }

        return code
    }

    private fun generateImportNode(node: ImportNode): String {
        var importLibs = "import '${node.library}';$lineFeed"

        if (node.child != null && node.child is ImportNode) {
            importLibs += generateImportNode(node.child as ImportNode)
        }

        return importLibs
    }

    private fun nodeRequired(node: Node): String {
        if (node is DataLeafNode && !node.nullable) {
            return "required "
        }

        if (node is DataObjectNode && !node.nullable) {
            return "required "
        }

        return ""
    }

    private fun generateNode(node: Node): String {
        if (node !is MultiNode) return ""

        val cls = nodeToClass(node)
        if (createdClass.contains(cls)) return ""

        createdClass.add(cls)

        var clsArgs = ""
        var clsConstructionArgs = ""
        var fromJson = ""
        var toJson = ""
        val extends = if (node is RootNode && node.sup.isNotEmpty()) "extends ${node.sup} " else ""
        val subNodes = mutableListOf<DataObjectNode>()

        for (child in node.children) {
            clsArgs += "$space${nodeToClsArg(child)}$lineFeed"
            clsConstructionArgs += "$space$space${nodeRequired(child)}this.${nodeName(child)},$lineFeed"
            fromJson += "$space$space${nodeToFromJson(child)}$lineFeed"
            toJson += "$space$space${nodeToJson(child)}$lineFeed"

            var tmpNode: Node = child
            while (true) {
                if (tmpNode !is DataObjectNode) break

                if (tmpNode.children.isEmpty()) break

                if (tmpNode.type == ValueType.Object) {
                    subNodes.add(tmpNode)
                    break
                }

                if (tmpNode.type == ValueType.Array) {
                    tmpNode = tmpNode.children[0]
                    continue
                }

                break
            }
        }

        var result = JsonTemplate.template(
            cls,
            extends,
            clsArgs.trimEnd(),
            clsConstructionArgs.trimEnd(),
            fromJson.trimEnd(),
            toJson.trimEnd()
        )

        subNodes.forEach { result += lineFeed + lineFeed + generateNode(it) }

        return result
    }

    private fun geneClassName(): String {
        clsNumber++
        return "SubItem$clsNumber"
    }

    private fun formatName(name: String): String {
        if (name == "") return ""

        val rn = name.replace(Regex("[^a-zA-Z0-9_]"), "")

        var formatName = ""
        val items = rn.split("_")
        for (item in items) {
            formatName += item[0].toUpperCase() + item.substring(1)
        }
        return formatName[0].toLowerCase() + formatName.substring(1)
    }

    private fun nodeName(node: Node): String {
        var name = ""
        if (node is DataLeafNode) {
            name = node.alias.ifEmpty { formatName(node.name) }
        } else if (node is DataObjectNode) {
            name = node.alias.ifEmpty { formatName(node.name) }
        }
        return name
    }

    private fun nodeToClass(node: Node): String {
        if (node.type == ValueType.Double) return "double"
        if (node.type == ValueType.Int) return "int"
        if (node.type == ValueType.String) return "String"
        if (node.type == ValueType.Bool) return "bool"

        if (node is RootNode) return node.cls

        if (node is DataObjectNode) {
            if (node.type == ValueType.Object) {
                val cls: String
                when {
                    node.cls.isNotEmpty() -> {
                        cls = node.cls
                    }
                    node.name.isNotEmpty() -> {
                        val name = nodeName(node)
                        cls = name[0].toUpperCase() + name.substring(1)
                    }
                    else -> {
                        node.cls = geneClassName()
                        cls = node.cls
                    }
                }
                return cls
            }

            if (node.type == ValueType.Array) {
                val cls: String = if (node.children.isEmpty()) {
                    "dynamic"
                } else {
                    nodeToClass(node.children.first())
                }

                return "List<$cls>"
            }
        }

        throw Exception("node to class failed, at line: ${node.source}")
    }

    private fun nodeToClsArg(node: Node): String {
        if (node is DataLeafNode) {
            val name = nodeName(node)
            var cls = nodeToClass(node)
            if (node.nullable) {
                cls += "?"
            }
            return "$cls $name;"
        }

        if (node is DataObjectNode) {
            val name = nodeName(node)
            var cls = nodeToClass(node)
            if (node.nullable) {
                cls += "?"
            }
            return "$cls $name;"
        }

        throw Exception("node to class arguments failed, at line: ${node.source}")
    }

    private fun mapToTypeList(nodeAry: DataObjectNode): String {
        val node = nodeAry.children.first()

        return when (node.type) {
            ValueType.Double -> "e.toDouble()"
            ValueType.Int, ValueType.String, ValueType.Bool -> "e"
            else -> "${nodeToClass(node)}.fromJson(e)"
        }
    }

    private fun typeListToMap(nodeAry: DataObjectNode): String {
        val node = nodeAry.children.first()

        return when (node.type) {
            ValueType.Double, ValueType.Int, ValueType.String, ValueType.Bool -> "e"
            else -> "e.toJson()"
        }
    }

    private fun nodeToFromJson(node: Node): String {
        if (node is DataLeafNode) {
            var text = "${nodeName(node)}: json['${node.name}']"
            if (node.type == ValueType.Double && node.nullable) {
                text += "?.toDouble()"
            }
            text += ","
            return text
        }

        if (node is DataObjectNode) {
            val json = "json['${node.name}']"

            if (node.type == ValueType.Object) {
                var text = "${nodeToClass(node)}.fromJson($json)"
                if (node.nullable) {
                    text = "$json != null ? $json : null"
                }
                text = "${nodeName(node)}: $text,"
                return text
            }

            if (node.type == ValueType.Array) {
                var text = "${nodeToClass(node)}.from($json.map((e) => ${mapToTypeList(node)}))"
                if (node.nullable) {
                    text = "$json != null ? $text : null"
                }
                text = "${nodeName(node)}: $text,"
                return text
            }
        }

        throw Exception("node to from json failed, at line: ${node.source}")
    }

    private fun nodeToJson(node: Node): String {
        if (node is DataLeafNode) {
            return "\"${node.name}\": ${nodeName(node)},"
        }

        if (node is DataObjectNode) {
            if (node.type == ValueType.Object) {
                val nullCode = if (node.nullable) "?" else ""
                var text = "${nodeName(node)}$nullCode.toJson()"
                text = "\"${node.name}\": $text,"
                return text
            }

            if (node.type == ValueType.Array) {
                val assertCode = if (node.nullable) "!" else ""
                var text = "List<dynamic>.from(${nodeName(node)}$assertCode.map((e) => ${typeListToMap(node)}))"
                if (node.nullable) {
                    text = "${nodeName(node)} != null ? $text : null"
                }
                text = "\"${node.name}\": $text,"
                return text
            }
        }

        throw Exception("node to from json failed, at line: ${node.source}")
    }
}
